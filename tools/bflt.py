#!/usr/bin/env python
#
# uCLinux 'bFLT' executable format reader
#
# Note that this is a minimal implementation intended to serve the needs of
# the bflt2cpm converter only.
#

import struct
import sys
import os

class BFLTFile(object):
	"""
	A bFLT executable generated by elf2flt (or similar).
	"""

	MAGIC = (0x62, 0x46, 0x4c, 0x54)
	FILE_VERSION = 4

	FLAG_RAM = 0x0001
	FLAG_GOTPIC = 0x0002
	FLAG_GZIP = 0x0004
	FLAG_GZDATA = 0x0008

	RELOC_TEXT = 0
	RELOC_DATA = 1
	RELOC_BSS = 2

	def __init__(self, withFile):
		fileBytes = bytearray(withFile.read())

		# check file magic number
		magic = struct.unpack('!4B', fileBytes[0:4])
		if magic != self.MAGIC:
			raise RuntimeError('not a bFLT file')

		# parse the header
		fmt = '!4xLLLLLLLL6x'
		headerSize = struct.calcsize(fmt)
		fields = struct.unpack(fmt, fileBytes[0:headerSize])
		(rev, entry, data_start, data_end, bss_end, stack_size, reloc_start, reloc_count, flags) = fields

		# check the revision
		if rev != self.FILE_VERSION:
			raise RuntimeError('bFLT version {} not supported, require 4'.format(rev))

		# check for incompatible flags
		if flags & (self.FLAG_GZIP | self.FLAG_GZDATA):
			raise RuntimeError('gzip compression not supported')
		if not (flags & self.FLAG_RAM):
			raise RuntimeError('XIP executable not supported, use -r option to elf2flt')

		self.text = fileBytes[entry:data_start]
		self.textSize = len(self.text)

		self.data = fileBytes[data_start:data_end]
		self.dataSize = len(self.data)

		self.bssSize = bss_end - data_end

		self.flags = flags
		self.relocs = fileBytes[reloc_start:reloc_start + (reloc_count * 4)]
