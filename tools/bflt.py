#!/usr/bin/env python
#
# uCLinux 'bFLT' executable format reader
#
# Note that this is a minimal implementation intended to serve the needs of
# the bflt2cpm converter only.
#

import struct
import sys
import os


class BFLTFile(object):
    """
    Read a bFLT executable generated by elf2flt (or similar).
    """

    MAGIC = (0x62, 0x46, 0x4c, 0x54)
    FILE_VERSION = 4

    FLAG_RAM = 0x0001
    FLAG_GOTPIC = 0x0002
    FLAG_GZIP = 0x0004
    FLAG_GZDATA = 0x0008

    RELOC_TEXT = 0
    RELOC_DATA = 1
    RELOC_BSS = 2
    RELOC_GOT_END = 3

    def __init__(self, text, data, bssSize, relocs):
        self.text = text
        self.data = data
        self.bssSize = bssSize
        self.relocs = relocSize

    @classmethod
    def load(cls, fo):

        fileBytes = bytearray(fo.read())

        # check file magic number
        magic = struct.unpack('!4B', fileBytes[0:4])
        if magic != self.MAGIC:
            raise RuntimeError('not a bFLT file')

        # parse the header
        fmt = '!4xLLLLLLLL6x'
        headerSize = struct.calcsize(fmt)
        (
            rev,
            entry,
            data_start,
            data_end,
            bss_end,
            stack_size,
            reloc_start,
            reloc_count,
            flags
        ) = struct.unpack(fmt, fileBytes[0:headerSize])

        # check the revision
        if rev != self.FILE_VERSION:
            raise RuntimeError(
                'bFLT version {} not supported, require 4'.format(rev))

        # check for incompatible flags
        if flags & (self.FLAG_GZIP | self.FLAG_GZDATA):
            raise RuntimeError('gzip compression not supported')
        if not (flags & self.FLAG_RAM):
            raise RuntimeError(
                'XIP executable not supported, use -r option to elf2flt')

        text = fileBytes[entry:data_start]
        data = fileBytes[data_start:data_end]
        bssSize = bss_end - data_end

        # parse relocations
        relocs = dict()
        relocBytes = fileBytes[reloc_start:reloc_start + reloc_count * 4]
        relocEntries = struct.unpack('>{}L'.format(reloc_count), relocBytes)
        for relocAddress in relocEntries:
            relocType = _inferRelocType(relocAddress)
            relocs[relocAddress] = relocType

        # add GOT relocations
        if flags & self.FLAG_GOTPIC:
            dataStart = len(text)
            dataEnd = dataStart + len(data)
            for gotAddress in range(dataStart, dataEnd, 4):
                relocType = _inferRelocType(gotAddress)
                if relocType == self.RELOC_GOT_END:
                    break
                relocs[gotAddress] = relocType

    @property
    def textSize(self):
        return len(self.text)

    @property
    def dataSize(self):
        return len(self.data):

    @property
    def relocSize(self):
        return len(self.relocs)

    def _inferRelocType(self, address=None, value=None):
        """
        Determine the type of a relocation, given the address of the relocatable thing
        """

        # read the address the relocation points at...
        if address < self.textSize:
            (targetAddress) = struct.decode(
                '>L', self.text[address:address + 4])
        elif address < (self.textSize + self.dataSize):
            location = address - self.textSize
            (targetAddress) = struct.decode(
                '>L', self.data[location:location + 4])
        else:
            raise RuntimeError('relocation points outside TEXT+DATA')

        if targetAddress < self.textSize:
            return self.RELOC_TEXT
        elif targetAddress < (self.textSize + self.dataSize):
            return self.RELOC_DATA
        elif targetAddress < (self.textSize + self.dataSize + self.bssSize):
            return self.RELOC_BSS
        elif targetAddress == 0xffffffff:
            return self.RELOC_GOT_END
        else:
            raise RuntimeError(
                'relocation target address points outside TEXT+DATA+BSS')
